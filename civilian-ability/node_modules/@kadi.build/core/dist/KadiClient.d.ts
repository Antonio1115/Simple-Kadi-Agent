import { EventEmitter } from 'events';
import { JSONSchema, BrokerConnection } from './types/core.js';
import type { TransportKind } from './types/core.js';
import { LoadedAbility } from './loadAbility.js';
export interface KadiClientConfig {
    /** Agent display name for identification */
    name?: string;
    /** Agent version string */
    version?: string;
    /** Human-readable description of the agent */
    description?: string;
    /** Role when connecting to broker - determines available operations */
    role?: 'agent' | 'ability';
    /** Transport used when serving requests */
    transport?: TransportKind;
    /** Primary network segment for message routing - defines which network this client operates in. Used for isolation and access control between different environments. */
    network?: string;
    /** Additional network identifiers this client belongs to - enables participation in multiple network segments simultaneously */
    networks?: string[];
    /** Named broker configurations - enables connection to multiple brokers simultaneously */
    brokers?: {
        [brokerName: string]: string;
    };
    /** Default broker name for message routing when no specific broker is targeted */
    defaultBroker?: string;
    /** Maximum buffer size for message handling (primarily for stdio protocol) */
    maxBufferSize?: number;
    /** Path to ability agent.json configuration file */
    abilityAgentJSON?: string;
}
export interface ToolSchema {
    name?: string;
    description?: string;
    inputSchema?: JSONSchema;
    outputSchema?: JSONSchema;
}
type ToolHandler = (params: unknown) => Promise<unknown>;
interface RegisteredTool {
    name: string;
    handler: ToolHandler;
    schema?: ToolSchema;
}
/**
 * KadiClient - Unified client for KADI protocol
 *
 * This class combines the functionality of KadiAgent and KadiAbility,
 * providing a single interface for:
 *
 * 1. Registering tools that can be called by others
 * 2. Calling remote tools on other services
 * 3. Supporting multiple protocols (native, stdio, broker)
 * 4. Connecting to broker with configurable role (agent, ability, service)
 *
 * @example
 * ```typescript
 * // Create as an ability
 * const service = new KadiClient({
 *   name: 'math-service',
 *   role: 'ability',
 *   protocol: 'broker'
 * });
 *
 * // Register tools
 * service.registerTool('add', async ({a, b}) => ({result: a + b}));
 *
 * // With schema
 * service.tool('multiply', async ({a, b}) => ({result: a * b}));
 *
 * // Start serving
 * await service.serve();
 * ```
 */
export declare class KadiClient extends EventEmitter {
    readonly name: string;
    readonly version: string;
    readonly description: string;
    readonly role: 'agent' | 'ability';
    transport: TransportKind;
    readonly network: string;
    readonly networks: string[];
    readonly brokers: {
        [brokerName: string]: string;
    };
    readonly defaultBroker?: string;
    readonly abilityAgentJSON?: string;
    private readonly logger;
    private transportHandler?;
    readonly toolHandlers: Map<string, RegisteredTool>;
    private readonly _abilities;
    private readonly _brokerConnections;
    private _isConnected;
    private _agentId;
    private _idFactory;
    private _pendingResponses;
    private _pendingToolCalls;
    private _currentBroker?;
    /**
     * Resolver function for the native protocol serve promise.
     * When serve() is called with native protocol, it creates a promise to keep
     * the process alive. This resolver allows us to resolve that promise during
     * disconnect(), enabling clean shutdown of native abilities.
     */
    private _nativeServePromiseResolve?;
    /**
     * Stores all event subscriptions as a Map of pattern â†’ array of callback functions
     * Example structure:
     * {
     *   'user.login' => [handleLogin, logLoginEvent],      // 2 functions listening to user.login
     *   'payment.*' => [processPayment],                   // 1 function listening to all payment events
     *   'system.shutdown' => [saveState, cleanupResources] // 2 functions for shutdown
     * }
     * When an event arrives, we check which patterns match and call all their callbacks
     */
    private _eventSubscriptions;
    constructor(options?: KadiClientConfig);
    /**
     * Get the currently active broker name
     */
    get currentBroker(): string | undefined;
    /**
     * Set the currently active broker
     * @param brokerName The name of the broker to use
     * @throws Error if the broker name doesn't exist in configuration
     */
    setCurrentBroker(brokerName: string): void;
    /**
     * Get the current broker's connection (if connected)
     */
    private getCurrentBrokerConnection;
    /**
     * Resolve broker configuration with agent.json integration
     * Precedence: Code brokers > agent.json brokers > environment defaults
     */
    private resolveBrokerConfiguration;
    /**
     * Resolve default broker with fallback logic
     * Priority: Explicit defaultBroker > agent.json defaultBroker > 'prod' key > first broker key
     */
    private resolveDefaultBroker;
    /**
     * Register a tool for this service
     *
     * @param name - Tool name
     * @param handler - Handler function
     * @param schema - Optional schema
     * @returns This instance for chaining
     */
    registerTool(name: string, handler: ToolHandler, schema?: ToolSchema): this;
    /**
     * Get all registered tool names
     */
    getToolNames(): string[];
    /**
     * Get all registered tools (agent compatibility)
     */
    getTools(): string[];
    /**
     * Check if a tool is registered
     */
    hasTool(name: string): boolean;
    /**
     * Get tool handler
     */
    getToolHandler(name: string): ToolHandler | undefined;
    /**
     * Get tool schema
     */
    getToolSchema(name: string): ToolSchema | undefined;
    /**
     * Publish an event
     */
    publishEvent(eventName: string, data?: any): void;
    /**
     * Connect to all configured brokers (for event subscription and/or broker protocol)
     * Always connects to ALL brokers defined in this.brokers for maximum redundancy
     */
    connectToBrokers(): Promise<void>;
    /**
     * Check if connected to a specific broker URL
     */
    isConnectedToBroker(url: string): boolean;
    /**
     * Connect to a single broker
     */
    connectToBroker(url: string, brokerName?: string): Promise<void>;
    /**
     * Perform KADI protocol handshake
     */
    private performHandshake;
    /**
     * Start heartbeat to keep broker connection alive
     * Sends ping messages at the specified interval to prevent timeout
     */
    private startHeartbeat;
    /**
     * Register capabilities with broker
     */
    private registerCapabilities;
    /**
     * Send request to broker and wait for response
     */
    private sendRequest;
    /**
     * Handle incoming broker messages
     */
    private handleBrokerMessage;
    /**
     * Handle tool invocation result from broker
     */
    private handleToolResult;
    /**
     * Handle incoming tool invocation request
     */
    private handleToolInvocation;
    /**
     * Extract tool definitions for broker registration
     */
    private extractToolsForBroker;
    /**
     * Start serving (main entry point)
     *
     * @param options - Optional serve options
     */
    serve(): Promise<void>;
    /**
     * Start the client (alias for serve for agent compatibility)
     */
    start(): Promise<void>;
    /**
     * Discover tools available from a remote agent
     *
     * This function queries the broker to find what tools
     * a specific remote agent provides.
     *
     * @param targetAgent - The name of the agent to discover tools from
     * @returns Array of tool names available from the target agent
     */
    discoverRemoteTools(targetAgent: string): Promise<string[]>;
    /**
     * Call a tool on a remote agent via the broker
     *
     * This function sends an RPC call through the broker to invoke
     * a specific tool on a remote agent.
     *
     * @param targetAgent - The name of the agent that has the tool
     * @param toolName - The tool name to invoke
     * @param params - The parameters to pass to the tool
     * @returns The result from the remote tool invocation
     */
    callTool<TInput = unknown, TOutput = unknown>(targetAgent: string, toolName: string, params?: TInput): Promise<TOutput>;
    /**
     * Send a request directly to the broker
     * Uses the current broker or the specified broker
     *
     * @param method The RPC method to call (e.g., 'kadi.ability.list')
     * @param params The parameters for the method
     * @param brokerName Optional broker name to use (overrides current broker)
     * @returns The response from the broker
     */
    sendBrokerRequest(method: string, params?: unknown, brokerName?: string): Promise<unknown>;
    /**
     * Load an external ability and make its methods available for calling
     *
     * This is the KadiClient's convenient wrapper for loading abilities. It handles
     * broker resolution from your client config and delegates the actual loading
     * to the standalone loadAbility() function.
     *
     * Note: This method delegates to the standalone loadAbility() function after
     * resolving broker configurations. If you need more control or don't have a
     * KadiClient instance, you can use the standalone loadAbility() function directly.
     *
     * @param nameOrPath - Which ability to load. Can be:
     *   - "ability-name" - loads from your installed abilities
     *   - "/path/to/ability" - loads from a folder path
     *
     * @param protocol - How to connect to the ability:
     *   - 'native': Load directly into this process (fastest, same language only)
     *   - 'stdio': Spawn as child process, communicate via stdin/stdout (any language)
     *   - 'broker': Connect via broker (ability runs anywhere, most flexible)
     *
     * @param options - Configuration for how to load the ability:
     *
     *   broker: Which named broker to use (from your KadiClient config). Only for 'broker' protocol.
     *     Example: 'prod', 'local', 'staging'
     *     Uses your current/default broker if not specified.
     *
     *   brokerUrl: Direct broker WebSocket URL. Only for 'broker' protocol.
     *     Example: 'ws://localhost:8080', 'wss://broker.company.com'
     *     Overrides the 'broker' option if provided.
     *
     *   networks: Which KADI networks to search for the ability. Only for 'broker' protocol.
     *     Example: ['global', 'team-alpha', 'dev-environment']
     *     search specific networks to find them. Defaults to ['global'] if not specified.
     *
     * @returns A proxy object that lets you call the ability's methods directly.
     *   Example: ability.processData({input: "hello"}) calls the ability's processData method.
     *
     * @example
     * // Load a JavaScript ability in the same process (fastest)
     * const mathLib = await client.loadAbility('math-utils', 'native');
     * const result = await mathLib.add({a: 5, b: 3}); // Returns 8
     *
     * @example
     * // Load a Go/Python/Rust ability via child process
     * const imageProcessor = await client.loadAbility('image-resizer', 'stdio');
     * const thumbnail = await imageProcessor.resize({image: buffer, size: '100x100'});
     *
     * @example
     * // Connect to an ability running on a remote broker (using named broker from config)
     * const aiService = await client.loadAbility('gpt-analyzer', 'broker', {
     *   broker: 'prod',  // Use the 'prod' broker from KadiClient config
     *   networks: ['ai-services', 'global']  // Look in these networks
     * });
     * const analysis = await aiService.analyze({text: "Hello world"});
     */
    loadAbility(nameOrPath: string, transport?: TransportKind, options?: {
        broker?: string;
        brokerUrl?: string;
        networks?: string[];
    }): Promise<LoadedAbility>;
    /**
     * Disconnect from brokers and cleanup resources
     */
    disconnect(): Promise<void>;
    /**
     * Helper to load agent.json exports
     */
    private _loadAgentJsonExports;
    /**
     * Find agent.json file
     * TODO: Not sure, but maybe this function can be moved to pathUtils.ts?
     */
    private _findAgentJson;
    /**
     * Subscribe to events with unified API across all protocols
     *
     * @param pattern Event pattern - exact string for native/stdio, wildcards supported for broker
     * @param callback Function to call when event is received
     * @returns Unsubscribe function
     */
    subscribeToEvent(pattern: string, callback: (data: any) => void): Promise<() => void>;
    /**
     * Subscribe to multiple events at once
     *
     * @param patterns Array of event patterns
     * @param callback Function to call when any event is received (receives eventName and data)
     * @returns Unsubscribe function that removes all subscriptions
     */
    subscribeToEvents(patterns: string[], callback: (eventName: string, data: any) => void): Promise<() => void>;
    /**
     * Unsubscribe from event pattern
     *
     * @param pattern Event pattern to unsubscribe from
     * @param callback Optional specific callback to remove (if not provided, removes all)
     */
    unsubscribeFromEvent(pattern: string, callback?: (data: any) => void): void;
    /**
     * Subscribe to an event only once
     *
     * @param pattern Event pattern
     * @param callback Function to call when event is received (auto-unsubscribes after first call)
     */
    onceEvent(pattern: string, callback: (data: any) => void): Promise<void>;
    /**
     * Setup universal event subscription that works regardless of client protocol
     *
     * @private
     * @param pattern Event pattern to subscribe to
     */
    /**
     * Marker to track if we've already set up the event transport infrastructure
     */
    private _eventTransportSetup;
    /**
     * Subscribe to broker events
     *
     * @private
     * @param pattern Event pattern to subscribe to
     */
    private _subscribeToBrokerEvent;
    /**
     * Setup broker event delivery handler
     *
     * @private
     */
    private _brokerEventHandlerSetup;
    private _setupBrokerEventHandler;
    /**
     * Clean up protocol-specific event subscription
     *
     * @private
     * @param pattern Event pattern to clean up
     */
    private _cleanupProtocolEventSubscription;
    /**
     * Check if event name matches pattern
     *
     * @private
     * @param eventName Event name to check
     * @param pattern Pattern to match against (supports wildcards for broker protocol)
     * @returns True if matches
     */
    private _matchesPattern;
    /**
     * Dispatch event to subscribers - This is the final delivery step
     *
     * After all the routing through transports and pattern matching,
     * this function actually calls the user's callback functions with the event data.
     *
     * Example: If user did `client.subscribeToEvent('user.login', myFunction)`
     * then when 'user.login' event arrives, this calls `myFunction(eventData)`
     *
     * @private
     * @param pattern Pattern that matched (e.g., 'user.login' or 'payment.*')
     * @param data Event data to pass to the callbacks
     */
    private _dispatchEvent;
    get isConnected(): boolean;
    get agentId(): string;
    get broker(): BrokerConnection | undefined;
    private _eventTransportReady;
    /**
     * Validate event pattern for all transports
     * @private
     */
    private _validateEventPattern;
    /**
     * Store event subscription locally
     * @private
     */
    private _storeEventSubscription;
    /**
     * Ensure event transport is ready (one-time setup, cached)
     * @private
     */
    private _ensureEventTransportReady;
    /**
     * Initialize event transport (one-time setup)
     * @private
     */
    private _initializeEventTransport;
    /**
     * Transport-specific pattern subscription
     * @private
     */
    private _subscribeToPattern;
    /**
     * Setup native event listener for ABILITY_EVENT_TRANSPORT
     * @private
     */
    private _setupNativeEventListener;
    /**
     * Setup stdio event listener with dual event path support
     *
     * IMPORTANT: Stdio transport needs TWO event paths because:
     * 1. Direct stdio events: from the stdio process itself via transportHandler
     * 2. Native events: from abilities loaded BY the stdio process via ABILITY_EVENT_TRANSPORT
     *
     * Example flow:
     * KadiClient (stdio transport) â†’ StdioProcess â†’ LoadedAbility (native events)
     *
     * Both the stdio process AND any abilities it loads can publish events,
     * so we need listeners for both event delivery mechanisms.
     *
     * @private
     */
    private _setupStdioEventListener;
}
export default KadiClient;
//# sourceMappingURL=KadiClient.d.ts.map