/**
 * Load an ability using the specified protocol
 *
 * Simplified implementation that focuses on the native protocol for now.
 * Stdio and broker support can be added back as needed.
 */
import { EventEmitter } from 'events';
export interface AbilityEvents extends EventEmitter {
    on(event: string, listener: (...args: any[]) => void): this;
    emit(event: string, ...args: any[]): boolean;
}
export interface LoadedAbility extends EventEmitter {
    events: AbilityEvents;
    __call(method: string, params: any): Promise<any>;
    __schema(method: string): {
        inputSchema?: any;
        outputSchema?: any;
    } | undefined;
    __disconnect(): Promise<void>;
    __discover?(options: {
        networks?: string[];
        includeProviders?: boolean;
    }): Promise<any[]>;
    [methodName: string]: any;
}
/**
 * Load an ability (standalone function)
 *
 * This is the core ability loading function that does the actual work. It's designed
 * as a standalone function for maximum flexibility - you can use it directly without
 * needing a KadiClient instance.
 *
 * Why standalone? This design allows:
 * - Simple ability loading without full KadiClient setup
 * - Use in lightweight scripts or utilities
 * - Direct control over all options without client configuration interference
 * - Testing and debugging individual ability loading scenarios
 *
 * The KadiClient.loadAbility() method is a convenient wrapper that calls this
 * function after resolving broker names from the client's configuration.
 *
 * @param nameOrPath - Which ability to load. Can be:
 *   - "ability-name" - loads from your installed abilities folder
 *   - "/absolute/path/to/ability" - loads from a specific directory path
 *
 * @param transportMode - How to connect to the ability:
 *   - 'native': Load directly into this process (fastest, JavaScript/TypeScript only)
 *   - 'stdio': Spawn as child process, communicate via stdin/stdout (any language)
 *   - 'broker': Connect via broker WebSocket (ability runs anywhere, most flexible)
 *
 * @param options - Transport-specific configuration:
 *
 *   existingClient: KadiClient instance to reuse (broker protocol only).
 *     Used internally when called from KadiClient.loadAbility() to reuse connections.
 *
 *   brokerUrl: Direct WebSocket URL (broker protocol only).
 *     Example: 'ws://localhost:8080', 'wss://broker.company.com'
 *     Must be provided when using broker protocol without existingClient.
 *
 *   brokerName: Human-readable name for the broker (broker protocol only).
 *     Used for logging and identification purposes.
 *
 *   spawnAbility: Whether to start the ability process first (broker protocol only).
 *     - true: Start the ability locally AND connect to it via broker
 *     - false (default): Just connect to an already-running ability
 *     Typically false in production where abilities run as separate processes.
 *
 *   networks: Which KADI networks to search for the ability (broker protocol only).
 *     Example: ['global', 'team-alpha', 'production']
 *     Networks are like public/private rooms in the broker where clients register
 *     and discover each other.
 *     Defaults to ['global'] if not specified.
 *
 * @returns A proxy object that lets you call the ability's methods directly.
 *   The proxy automatically handles protocol communication (native imports, stdio JSON-RPC,
 *   or broker WebSocket messages) and presents a clean JavaScript API.
 *
 * @example
 * // Direct ability loading without KadiClient
 * import { loadAbility } from '@kadi.build/core';
 *
 * // Load local JavaScript ability
 * const mathLib = await loadAbility('math-utils', 'native');
 * const result = await mathLib.add({a: 5, b: 3});
 *
 * @example
 * // Load cross-language ability via stdio
 * const hashAbility = await loadAbility('hash-go', 'stdio');
 * const digest = await hashAbility.digest({text: "hello", algo: "sha256"});
 *
 * @example
 * // Load remote ability via direct broker connection
 * const aiAbility = await loadAbility('gpt-analyzer', 'broker', {
 *   brokerUrl: 'wss://production-broker.company.com',
 *   networks: ['ai-abilities', 'production']
 * });
 * const analysis = await aiAbility.analyze({text: "Hello world"});
 */
export declare function loadAbility(nameOrPath: string, transportMode?: 'native' | 'stdio' | 'broker', options?: {
    brokerUrl?: string;
    brokerName?: string;
    networks?: string[];
    existingClient?: any;
}): Promise<LoadedAbility>;
//# sourceMappingURL=loadAbility.d.ts.map