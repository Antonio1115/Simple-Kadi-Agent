import { ExecOptions, ChildProcess } from 'node:child_process';
import { Readable } from 'node:stream';
export interface CommandResult {
    stdout: string;
    stderr: string;
    code: number;
}
export interface StreamingCommand {
    stdout: Readable | null;
    stderr: Readable | null;
    kill: () => boolean;
    promise: Promise<CommandResult>;
    process: ChildProcess;
}
/**
 * Execute a command and return the complete output
 * Use this for commands with bounded output
 * @param name - The name of the ability or context
 * @param version - The version of the ability
 * @param command - The command to execute
 */
export declare function runExecCommand(name: string, version: string, command: string): Promise<CommandResult>;
/**
 * Spawn a command for streaming output
 * Use this for long-running commands or large outputs
 * @param name - The name of the ability or context
 * @param version - The version of the ability
 * @param command - The command to execute
 */
export declare function runSpawnCommand(name: string, version: string, command: string): Promise<StreamingCommand>;
/**
 * Generic command execution with options
 * @param command - The command to execute
 * @param options - Execution options
 */
export declare function runCommand(command: string, options?: ExecOptions): Promise<CommandResult>;
/**
 * Run command with timeout
 */
export declare function runCommandWithTimeout(command: string, timeoutMs: number, options?: ExecOptions): Promise<CommandResult>;
/**
 * Check if a command exists in PATH
 */
export declare function commandExists(command: string): Promise<boolean>;
//# sourceMappingURL=commandUtils.d.ts.map