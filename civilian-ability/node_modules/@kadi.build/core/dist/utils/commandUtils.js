import { exec, spawn } from 'node:child_process';
import { promisify } from 'node:util';
import path from 'node:path';
import { rootDir } from './pathUtils.js';
const execAsync = promisify(exec);
/**
 * Execute a command and return the complete output
 * Use this for commands with bounded output
 * @param name - The name of the ability or context
 * @param version - The version of the ability
 * @param command - The command to execute
 */
export async function runExecCommand(name, version, command) {
    const abilityPath = path.join(rootDir, 'abilities', name, version);
    return new Promise((resolve, reject) => {
        exec(command, { cwd: abilityPath }, (error, stdout, stderr) => {
            if (error) {
                // Even on error, we want to return the output
                resolve({
                    stdout: stdout?.toString() || '',
                    stderr: stderr?.toString() || error.message,
                    code: error.code || 1
                });
            }
            else {
                resolve({
                    stdout: stdout?.toString() || '',
                    stderr: stderr?.toString() || '',
                    code: 0
                });
            }
        });
    });
}
/**
 * Spawn a command for streaming output
 * Use this for long-running commands or large outputs
 * @param name - The name of the ability or context
 * @param version - The version of the ability
 * @param command - The command to execute
 */
export async function runSpawnCommand(name, version, command) {
    const abilityPath = path.join(rootDir, 'abilities', name, version);
    return new Promise((resolve, reject) => {
        const [cmd, ...args] = command.split(' ');
        const child = spawn(cmd, args, {
            cwd: abilityPath,
            shell: true
        });
        // Create promise for final result
        const promise = new Promise((resolveResult) => {
            let stdout = '';
            let stderr = '';
            child.stdout?.on('data', (chunk) => {
                stdout += chunk.toString();
            });
            child.stderr?.on('data', (chunk) => {
                stderr += chunk.toString();
            });
            child.on('error', (error) => {
                resolveResult({
                    stdout,
                    stderr: stderr || error.message,
                    code: 1
                });
            });
            child.on('exit', (code) => {
                resolveResult({
                    stdout,
                    stderr,
                    code: code || 0
                });
            });
        });
        resolve({
            stdout: child.stdout,
            stderr: child.stderr,
            kill: () => child.kill(),
            promise,
            process: child
        });
    });
}
/**
 * Generic command execution with options
 * @param command - The command to execute
 * @param options - Execution options
 */
export async function runCommand(command, options = {}) {
    try {
        const { stdout, stderr } = await execAsync(command, {
            encoding: 'utf8',
            ...options
        });
        return {
            stdout: stdout.toString(),
            stderr: stderr.toString(),
            code: 0
        };
    }
    catch (error) {
        // Exec error includes stdout/stderr even on failure
        return {
            stdout: error.stdout?.toString() || '',
            stderr: error.stderr?.toString() || error.message,
            code: error.code || 1
        };
    }
}
/**
 * Run command with timeout
 */
export async function runCommandWithTimeout(command, timeoutMs, options = {}) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), timeoutMs);
    try {
        const result = await runCommand(command, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(timeout);
        return result;
    }
    catch (error) {
        clearTimeout(timeout);
        if (error.code === 'ABORT_ERR') {
            throw new Error(`Command timed out after ${timeoutMs}ms`);
        }
        throw error;
    }
}
/**
 * Check if a command exists in PATH
 */
export async function commandExists(command) {
    const checkCommand = process.platform === 'win32' ? `where ${command}` : `which ${command}`;
    try {
        const result = await runCommand(checkCommand);
        return result.code === 0;
    }
    catch {
        return false;
    }
}
//# sourceMappingURL=commandUtils.js.map