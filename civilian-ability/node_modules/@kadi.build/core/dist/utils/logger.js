import createDebugLogger from 'debug';
import chalk from 'chalk';
// Typed logger storage
const loggerCache = new Map();
// Pre-configured loggers for backward compatibility
export const loggers = {
    main: null,
    ability: null,
    broker: null,
    ipc: null,
    transport: null,
    rpc: null
};
// Initialize default loggers
function initializeDefaultLoggers() {
    loggers.main = createLogger('main');
    loggers.ability = createLogger('ability');
    loggers.broker = createLogger('broker');
    loggers.ipc = createLogger('ipc');
    loggers.transport = createLogger('transport');
    loggers.rpc = createLogger('rpc');
}
/**
 * Creates a namespaced logger with sub-loggers for different concerns
 * @param namespace - The logger namespace (e.g., 'ability', 'broker')
 * @returns A logger instance with specialized sub-loggers
 */
export function createLogger(namespace) {
    // Check cache first
    if (loggerCache.has(namespace)) {
        return loggerCache.get(namespace);
    }
    const baseNamespace = `kadi:${namespace}`;
    const logger = createDebugLogger(baseNamespace);
    // Create typed sub-loggers
    logger.trace = createDebugLogger(`${baseNamespace}:trace`);
    logger.error = createDebugLogger(`${baseNamespace}:error`);
    logger.lifecycle = createDebugLogger(`${baseNamespace}:lifecycle`);
    logger.protocol = createDebugLogger(`${baseNamespace}:protocol`);
    logger.transport = createDebugLogger(`${baseNamespace}:transport`);
    logger.info = createDebugLogger(`${baseNamespace}:info`);
    logger.warn = createDebugLogger(`${baseNamespace}:warn`);
    logger.debug = createDebugLogger(`${baseNamespace}:debug`);
    // Add colored output for different log levels
    const originalError = logger.error;
    logger.error = ((message, ...args) => {
        if (process.stdout.isTTY) {
            originalError(chalk.red(message), ...args);
        }
        else {
            originalError(message, ...args);
        }
    });
    const originalWarn = logger.warn;
    logger.warn = ((message, ...args) => {
        if (process.stdout.isTTY) {
            originalWarn(chalk.yellow(message), ...args);
        }
        else {
            originalWarn(message, ...args);
        }
    });
    loggerCache.set(namespace, logger);
    return logger;
}
/**
 * Creates a logger for a specific component within a namespace
 */
export function createComponentLogger(component) {
    return createLogger(component);
}
/**
 * Checks if debug is enabled for a namespace
 */
export function isDebugEnabled(namespace) {
    const debug = process.env.DEBUG || '';
    // Handle wildcard patterns
    if (debug.includes('*')) {
        const patterns = debug.split(',').map((p) => p.trim());
        return patterns.some((pattern) => {
            const regex = pattern.replace(/\*/g, '.*');
            return new RegExp(`^${regex}$`).test(namespace);
        });
    }
    return debug.includes(namespace);
}
/**
 * Format an object for logging
 */
export function formatObject(obj, label = '') {
    if (label) {
        return `${label}: ${JSON.stringify(obj, null, 2)}`;
    }
    return JSON.stringify(obj, null, 2);
}
/**
 * Create a child logger with additional context
 */
export function createChildLogger(parentLogger, context) {
    const namespace = parentLogger.namespace.replace('kadi:', '');
    return createLogger(`${namespace}:${context}`);
}
// Type guard for checking if something is a logger
export function isKadiLogger(obj) {
    return (obj !== null &&
        typeof obj === 'function' &&
        'trace' in obj &&
        'error' in obj &&
        'lifecycle' in obj);
}
// Initialize default loggers on module load
initializeDefaultLoggers();
// Default export for backward compatibility
export default {
    loggers,
    createLogger,
    createComponentLogger,
    isDebugEnabled,
    formatObject,
    createChildLogger
};
//# sourceMappingURL=logger.js.map