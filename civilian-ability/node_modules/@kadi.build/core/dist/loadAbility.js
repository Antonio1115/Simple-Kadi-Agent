/**
 * Load an ability using the specified protocol
 *
 * Simplified implementation that focuses on the native protocol for now.
 * Stdio and broker support can be added back as needed.
 */
import path from 'node:path';
import fs from 'node:fs';
import { EventEmitter } from 'events';
import { NativeTransport } from './transports/NativeTransport.js';
import { StdioTransport } from './transports/StdioTransport.js';
import { BrokerTransport } from './transports/BrokerTransport.js';
import { createComponentLogger } from './utils/logger.js';
import { getAbilityJSON, getAbilitiesDir, getAbilityVersionFromArray, getProjectJSON } from './utils/agentUtils.js';
import { KadiError, CoreErrorCodes } from './errors/error-codes.js';
const logger = createComponentLogger('loadAbility');
/**
 * Proxy object that provides method access to abilities
 */
class AbilityProxy extends EventEmitter {
    name;
    transport;
    events;
    constructor(name, transport) {
        super();
        this.name = name;
        this.transport = transport;
        // Create events emitter for compatibility with examples
        this.events = new EventEmitter();
        // Forward events from transport if it supports them
        try {
            if (transport && typeof transport.on === 'function') {
                logger.trace('AbilityProxy', `Setting up transport event listener for ${name}`);
                transport.on('event', (eventData) => {
                    logger.trace('AbilityProxy', `Received event from transport: ${JSON.stringify(eventData)}`);
                    this.emit('event', eventData);
                    this.events.emit('event', eventData);
                    if (eventData.name) {
                        logger.debug('AbilityProxy', `Emitting specific event: ${eventData.name}`);
                        this.emit(eventData.name, eventData.data);
                        this.events.emit(eventData.name, eventData.data);
                    }
                });
            }
            else {
                logger.debug('AbilityProxy', `Transport doesn't support .on() method for ${name}`);
            }
        }
        catch (e) {
            // Handler doesn't support events, that's ok
            logger.debug('AbilityProxy', `Error setting up event listener for ${name}: ${e}`);
        }
    }
    async __call(method, params) {
        return this.transport.invoke(method, params);
    }
    /**
     * Get schema for a specific method (for TypeScript types)
     */
    __schema(method) {
        if ('getMethodSchema' in this.transport &&
            typeof this.transport.getMethodSchema === 'function') {
            const schema = this.transport.getMethodSchema(method);
            if (schema) {
                // Convert from handler's format to expected format
                return {
                    inputSchema: schema.input || schema.inputSchema,
                    outputSchema: schema.output || schema.outputSchema
                };
            }
        }
        return undefined;
    }
    async __disconnect() {
        await this.transport.disconnect();
    }
    /**
     * Get list of available tools/methods
     */
    getTools() {
        return this.transport.getMethods();
    }
    /**
     * Discover available methods from the broker (broker protocol only)
     */
    async __discover(options = {}) {
        if ('discoverMethods' in this.transport &&
            typeof this.transport.discoverMethods === 'function') {
            return this.transport.discoverMethods(options);
        }
        else {
            throw new Error(`Method discovery not supported for ${this.transport.constructor.name} protocol`);
        }
    }
}
/**
 * Resolve ability information from various sources
 */
function resolveAbilityInfo(nameOrPath) {
    // Check if it's a direct path
    if (fs.existsSync(nameOrPath)) {
        const stats = fs.statSync(nameOrPath);
        if (stats.isDirectory()) {
            return {
                name: path.basename(nameOrPath),
                version: '1.0.0',
                dir: nameOrPath,
                agentJson: null
            };
        }
    }
    // Parse name@version format
    const match = nameOrPath.match(/^(.+?)(?:@(.+))?$/);
    if (!match) {
        throw new KadiError(CoreErrorCodes.CORE_ABILITY_PATH_INVALID.code, `Invalid ability name format: ${nameOrPath}`, {
            abilityName: nameOrPath
        });
    }
    const [, name, requestedVersion] = match;
    // Look for the ability in standard locations
    const abilitiesDir = getAbilitiesDir();
    const projectJSON = getProjectJSON();
    const abilities = projectJSON?.abilities;
    if (abilities && abilities[name]) {
        const versions = abilities[name];
        // Handle both array and string formats for versions
        const version = requestedVersion ||
            (Array.isArray(versions)
                ? getAbilityVersionFromArray(versions, name)
                : typeof versions === 'string'
                    ? versions
                    : '1.0.0');
        const dir = path.join(abilitiesDir, name, version);
        return {
            name,
            version,
            dir,
            agentJson: getAbilityJSON(name, version)
        };
    }
    // Check if it exists as a directory in abilities folder
    const abilityDir = path.join(abilitiesDir, name);
    if (fs.existsSync(abilityDir)) {
        return {
            name,
            version: requestedVersion || '1.0.0',
            dir: abilityDir,
            agentJson: null
        };
    }
    throw KadiError.abilityNotFound(name);
}
/**
 * Load an ability (standalone function)
 *
 * This is the core ability loading function that does the actual work. It's designed
 * as a standalone function for maximum flexibility - you can use it directly without
 * needing a KadiClient instance.
 *
 * Why standalone? This design allows:
 * - Simple ability loading without full KadiClient setup
 * - Use in lightweight scripts or utilities
 * - Direct control over all options without client configuration interference
 * - Testing and debugging individual ability loading scenarios
 *
 * The KadiClient.loadAbility() method is a convenient wrapper that calls this
 * function after resolving broker names from the client's configuration.
 *
 * @param nameOrPath - Which ability to load. Can be:
 *   - "ability-name" - loads from your installed abilities folder
 *   - "/absolute/path/to/ability" - loads from a specific directory path
 *
 * @param transportMode - How to connect to the ability:
 *   - 'native': Load directly into this process (fastest, JavaScript/TypeScript only)
 *   - 'stdio': Spawn as child process, communicate via stdin/stdout (any language)
 *   - 'broker': Connect via broker WebSocket (ability runs anywhere, most flexible)
 *
 * @param options - Transport-specific configuration:
 *
 *   existingClient: KadiClient instance to reuse (broker protocol only).
 *     Used internally when called from KadiClient.loadAbility() to reuse connections.
 *
 *   brokerUrl: Direct WebSocket URL (broker protocol only).
 *     Example: 'ws://localhost:8080', 'wss://broker.company.com'
 *     Must be provided when using broker protocol without existingClient.
 *
 *   brokerName: Human-readable name for the broker (broker protocol only).
 *     Used for logging and identification purposes.
 *
 *   spawnAbility: Whether to start the ability process first (broker protocol only).
 *     - true: Start the ability locally AND connect to it via broker
 *     - false (default): Just connect to an already-running ability
 *     Typically false in production where abilities run as separate processes.
 *
 *   networks: Which KADI networks to search for the ability (broker protocol only).
 *     Example: ['global', 'team-alpha', 'production']
 *     Networks are like public/private rooms in the broker where clients register
 *     and discover each other.
 *     Defaults to ['global'] if not specified.
 *
 * @returns A proxy object that lets you call the ability's methods directly.
 *   The proxy automatically handles protocol communication (native imports, stdio JSON-RPC,
 *   or broker WebSocket messages) and presents a clean JavaScript API.
 *
 * @example
 * // Direct ability loading without KadiClient
 * import { loadAbility } from '@kadi.build/core';
 *
 * // Load local JavaScript ability
 * const mathLib = await loadAbility('math-utils', 'native');
 * const result = await mathLib.add({a: 5, b: 3});
 *
 * @example
 * // Load cross-language ability via stdio
 * const hashAbility = await loadAbility('hash-go', 'stdio');
 * const digest = await hashAbility.digest({text: "hello", algo: "sha256"});
 *
 * @example
 * // Load remote ability via direct broker connection
 * const aiAbility = await loadAbility('gpt-analyzer', 'broker', {
 *   brokerUrl: 'wss://production-broker.company.com',
 *   networks: ['ai-abilities', 'production']
 * });
 * const analysis = await aiAbility.analyze({text: "Hello world"});
 */
export async function loadAbility(nameOrPath, transportMode = 'native', options = {}) {
    logger.lifecycle('loadAbility', `Loading ability: ${nameOrPath}`);
    if (transportMode !== 'native' &&
        transportMode !== 'stdio' &&
        transportMode !== 'broker') {
        throw new KadiError(CoreErrorCodes.CORE_PROTOCOL_UNSUPPORTED.code, `Transport '${transportMode}' not yet supported. Available: 'native', 'stdio', 'broker'`, {
            transport: transportMode,
            abilityName: nameOrPath
        });
    }
    // Resolve ability information depending on transport
    // For broker, we don't need local files (client-only mode)
    let name, version, abilityDir, agentJson;
    if (transportMode === 'broker') {
        name = nameOrPath;
        version = '1.0.0';
        abilityDir = null;
        agentJson = null;
        logger.info('Broker client mode', {
            targetAgent: name,
            transport: transportMode,
            brokerUrl: options.brokerUrl
        });
    }
    else {
        const resolved = resolveAbilityInfo(nameOrPath);
        name = resolved.name;
        version = resolved.version;
        abilityDir = resolved.dir;
        agentJson = resolved.agentJson;
        logger.info('Resolved ability', {
            name,
            version,
            dir: abilityDir,
            transport: transportMode
        });
    }
    // Create transport implementation based on the requested mode
    let selectedTransport;
    if (transportMode === 'native') {
        if (!abilityDir) {
            throw new KadiError(CoreErrorCodes.CORE_ABILITY_LOAD_FAILED.code, 'Native protocol requires local ability files', {
                transport: 'native',
                abilityName: name
            });
        }
        selectedTransport = new NativeTransport({
            abilityName: name,
            abilityVersion: version,
            abilityDir
        });
    }
    else if (transportMode === 'stdio') {
        if (!abilityDir) {
            throw new KadiError(CoreErrorCodes.CORE_ABILITY_LOAD_FAILED.code, 'Stdio protocol requires local ability files', {
                transport: 'stdio',
                abilityName: name
            });
        }
        const startCmd = agentJson?.scripts?.start;
        if (!startCmd) {
            throw new KadiError(CoreErrorCodes.CORE_CONFIG_MISSING.code, `Ability '${name}' is missing scripts.start in agent.json for stdio transport`, {
                transport: 'stdio',
                abilityName: name
            });
        }
        selectedTransport = new StdioTransport({
            abilityName: name,
            abilityVersion: version,
            abilityDir,
            startCmd
        });
    }
    else if (transportMode === 'broker') {
        // For broker protocol, get broker URL and other settings
        const brokerUrl = options.brokerUrl || 'ws://localhost:8080';
        // Get networks from options or default
        const networks = options.networks || ['global'];
        selectedTransport = new BrokerTransport({
            targetAgent: name, // The remote agent we want to call
            abilityName: name,
            abilityVersion: version,
            existingClient: options.existingClient, // Reuse existing client if provided
            brokerUrl,
            brokerName: options.brokerName,
            networks
        });
    }
    else {
        throw new KadiError(CoreErrorCodes.CORE_PROTOCOL_UNSUPPORTED.code, 'Unsupported transport mode', {
            transport: transportMode,
            abilityName: name
        });
    }
    // Connect
    try {
        await selectedTransport.connect();
    }
    catch (error) {
        if (error instanceof KadiError) {
            throw error; // Re-throw KadiErrors as-is
        }
        // For broker protocol, connection errors should be treated
        // as broker connection failures
        if (transportMode === 'broker') {
            throw KadiError.brokerUnavailable(options.brokerUrl || 'ws://localhost:8080', error);
        }
        // For other protocols, wrap in generic ability load failure
        throw KadiError.fromError(error, CoreErrorCodes.CORE_ABILITY_LOAD_FAILED.code, {
            transport: transportMode,
            abilityName: name,
            abilityVersion: version
        });
    }
    logger.info('Loaded ability', name);
    // Create and return proxy
    const proxy = new AbilityProxy(name, selectedTransport);
    // Use a JavaScript Proxy to intercept any method calls and relay them
    return new Proxy(proxy, {
        get(target, prop, receiver) {
            // If the property exists on the target, return it
            if (prop in target) {
                return Reflect.get(target, prop, receiver);
            }
            // Avoid being treated as a Promise/thenable
            if (prop === 'then')
                return undefined;
            // If it's a string and looks like a method name, create a method proxy
            if (typeof prop === 'string' && !prop.startsWith('_')) {
                return async (params) => {
                    try {
                        return await target.__call(prop, params);
                    }
                    catch (error) {
                        throw new Error(`Failed to call method '${prop}' on ability '${name}'.\n` +
                            `Original error: ${error instanceof Error ? error.message : String(error)}\n` +
                            `Check if the method name is correct.`);
                    }
                };
            }
            return undefined;
        }
    });
}
//# sourceMappingURL=loadAbility.js.map