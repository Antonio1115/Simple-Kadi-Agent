/**
 * Event System Schema Validation
 * ------------------------------
 * Zod schemas for validating event system parameters and messages.
 * This ensures type safety and proper input validation for all event operations.
 *
 * The schemas follow the established patterns in the KADI broker for consistency
 * and integrate with the existing validation middleware.
 */
import { z } from 'zod';
import { NetworkIdSchema } from './kadi.schemas.js';
// ============================================================================
// EVENT CHANNEL VALIDATION
// ============================================================================
/**
 * Event channel pattern validation schema.
 *
 * Enforces the hierarchical naming convention:
 * - Format: namespace.event-name or namespace.category.event-name
 * - Examples: 'system.startup', 'tool.completed', 'agent.status.changed'
 * - Wildcards: '*' matches one segment, '#' matches multiple segments
 *
 * Rules:
 * - Must start with lowercase letter
 * - Segments separated by dots
 * - Only lowercase letters, numbers, underscores, hyphens allowed
 * - Wildcards * and # only allowed at end of segments
 */
export const EventChannelSchema = z
    .string()
    .min(1, 'Event channel cannot be empty')
    .max(128, 'Event channel too long')
    .regex(/^[a-z][a-z0-9_-]*(?:\.[a-z0-9_*#-]+)*$/, 'Event channel must use lowercase with dots (e.g., "system.startup", "tool.*", "agent.#")')
    .describe('Event channel pattern for subscriptions');
// ============================================================================
// EVENT SUBSCRIPTION SCHEMAS
// ============================================================================
/**
 * Schema for event subscription requests (kadi.event.subscribe)
 */
export const EventSubscribeSchema = z
    .object({
    /** Array of event channel patterns to subscribe to */
    channels: z
        .array(EventChannelSchema)
        .min(1, 'Must specify at least one channel')
        .max(50, 'Too many channels in single subscription'),
    /** Optional network to subscribe within - defaults to agent's networks */
    networkId: NetworkIdSchema.optional(),
    /** Optional filters to reduce event volume */
    filter: z
        .object({
        /** Only receive events from specific publisher */
        publisherId: z.string().optional(),
        /** Only receive events with matching metadata */
        metadata: z.record(z.string(), z.unknown()).optional()
    })
        .optional()
})
    .strict(); // Prevent additional properties
/**
 * Schema for event subscription response
 */
export const EventSubscribeResultSchema = z
    .object({
    /** Channels that were successfully subscribed to */
    subscribed: z.array(EventChannelSchema),
    /** Internal queue name for debugging/monitoring */
    queueName: z.string()
})
    .strict();
// ============================================================================
// EVENT UNSUBSCRIPTION SCHEMAS
// ============================================================================
/**
 * Schema for event unsubscription requests (kadi.event.unsubscribe)
 */
export const EventUnsubscribeSchema = z
    .object({
    /** Channel patterns to unsubscribe from */
    channels: z
        .array(EventChannelSchema)
        .min(1, 'Must specify at least one channel'),
    /** Network to unsubscribe from - defaults to 'global' */
    networkId: NetworkIdSchema.optional()
})
    .strict();
/**
 * Schema for event unsubscription response
 */
export const EventUnsubscribeResultSchema = z
    .object({
    /** Channels that were successfully unsubscribed */
    unsubscribed: z.array(EventChannelSchema)
})
    .strict();
// ============================================================================
// EVENT PUBLISHING SCHEMAS
// ============================================================================
/**
 * Schema for event publishing requests (kadi.event.publish)
 */
export const EventPublishSchema = z
    .object({
    /** Event channel to publish to - must not contain wildcards */
    channel: EventChannelSchema.refine((channel) => !channel.includes('*') && !channel.includes('#'), 'Cannot publish to wildcard channels - use specific channel names'),
    /** Event payload data - any serializable value */
    data: z.unknown(),
    /** Networks to publish to - defaults to publisher's networks */
    networks: z
        .array(NetworkIdSchema)
        .max(10, 'Cannot publish to more than 10 networks at once')
        .optional(),
    /** Optional metadata to include with the event */
    metadata: z.record(z.string(), z.unknown()).optional()
})
    .strict();
/**
 * Schema for event publishing response
 */
export const EventPublishResultSchema = z
    .object({
    /** Whether the event was successfully published */
    published: z.boolean(),
    /** Unique identifier for this event (for tracking/debugging) */
    eventId: z.string().uuid()
})
    .strict();
// ============================================================================
// EVENT LISTING SCHEMAS
// ============================================================================
/**
 * Schema for event subscription listing requests (kadi.event.list)
 */
export const EventListSchema = z
    .object({
    /** Filter subscriptions by agent ID */
    agentId: z.string().optional(),
    /** Filter subscriptions by network */
    networkId: NetworkIdSchema.optional()
})
    .strict();
/**
 * Schema for event subscription listing response
 */
export const EventListResultSchema = z
    .object({
    /** Array of active subscriptions */
    subscriptions: z.array(z.object({
        agentId: z.string(),
        channels: z.array(EventChannelSchema),
        networks: z.array(NetworkIdSchema),
        queueName: z.string(),
        subscribedAt: z.string().datetime() // ISO 8601 timestamp
    }))
})
    .strict();
// ============================================================================
// EVENT MESSAGE SCHEMAS
// ============================================================================
/**
 * Schema for validating event messages before delivery.
 * This ensures all events have consistent structure when delivered to subscribers.
 */
export const EventMessageSchema = z
    .object({
    /** The channel this event was published to */
    channel: EventChannelSchema,
    /** Event-specific payload data */
    data: z.unknown(),
    /** ISO 8601 timestamp when event was published */
    timestamp: z.string().datetime(),
    /** ID of the agent/tool that published this event */
    publisherId: z.string(),
    /** Network where this event was published */
    networkId: NetworkIdSchema,
    /** Optional metadata for correlation and tracking */
    metadata: z
        .object({
        /** For tracking related events across the system */
        correlationId: z.string().optional(),
        /** Event schema version for evolution */
        version: z.string().optional(),
        /** Event ID for deduplication and tracing */
        eventId: z.string().uuid().optional(),
        /** Role of the publisher (agent, tool, system) */
        publisherRole: z.string().optional()
        /** Additional custom metadata */
    })
        .catchall(z.unknown())
        .optional() // Allow additional metadata fields
})
    .strict();
// ============================================================================
// VALIDATION MIDDLEWARE INTEGRATION
// ============================================================================
/**
 * Validation middleware for event system methods.
 * Extends the existing ValidationMiddleware pattern to support event operations.
 */
export class EventValidationMiddleware {
    /**
     * Validates parameters for event system methods using appropriate schemas
     */
    static validateEventParams(method, params) {
        switch (method) {
            case 'kadi.event.subscribe':
                return EventSubscribeSchema.parse(params);
            case 'kadi.event.unsubscribe':
                return EventUnsubscribeSchema.parse(params);
            case 'kadi.event.publish':
                return EventPublishSchema.parse(params);
            case 'kadi.event.list':
                return EventListSchema.parse(params);
            default:
                // For non-event methods, return params as-is
                return params;
        }
    }
    /**
     * Validates event message structure before delivery
     */
    static validateEventMessage(message) {
        return EventMessageSchema.parse(message);
    }
    /**
     * Provides user-friendly error messages for common validation failures
     */
    static getValidationHint(method, error) {
        const firstError = error.issues[0];
        switch (method) {
            case 'kadi.event.subscribe':
                if (firstError?.path.includes('channels')) {
                    return 'Check channel format: use lowercase with dots (e.g., "system.startup", "tool.*")';
                }
                break;
            case 'kadi.event.publish':
                if (firstError?.path.includes('channel')) {
                    return 'Channel must be specific (no wildcards) and use lowercase.separated format';
                }
                if (firstError?.path.includes('networks')) {
                    return 'Networks must be an array of valid network IDs';
                }
                break;
            default:
                return 'Check your event parameters for correct format and types';
        }
        return 'Check the event system documentation for parameter requirements';
    }
}
// ============================================================================
// SCHEMA EXPORTS FOR EXTERNAL USE
// ============================================================================
/**
 * Export all schemas for use in tests and external validation
 */
export const EventSchemas = {
    EventChannel: EventChannelSchema,
    EventSubscribe: EventSubscribeSchema,
    EventUnsubscribe: EventUnsubscribeSchema,
    EventPublish: EventPublishSchema,
    EventList: EventListSchema,
    EventMessage: EventMessageSchema
};
//# sourceMappingURL=events.schemas.js.map