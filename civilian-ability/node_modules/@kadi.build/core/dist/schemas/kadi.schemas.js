import { z } from 'zod';
// ============================================================================
// NETWORK VALIDATION SCHEMAS
// ============================================================================
// Network ID validation
export const NetworkIdSchema = z
    .string()
    .min(1)
    .max(128)
    .regex(/^[a-z0-9][a-z0-9-_.]*$/i)
    .describe('Network identifier');
// Tool name validation - Supports both legacy and namespaced formats
// Namespaced format: <namespace>/<name>@<major>[.<minor>]
// Legacy format: simple name (will be auto-normalized)
// Examples: 'data/analyze_dataset@1', 'kadi/echo@1.0', 'legacy_tool'
export const ToolNameSchema = z
    .string()
    .min(1)
    .max(128)
    .refine((val) => {
    // Allow legacy format (simple names)
    const legacyRegex = /^[a-zA-Z][a-zA-Z0-9_-]*$/;
    // Strict namespaced format
    const namespacedRegex = /^[a-z0-9][a-z0-9._-]*\/[a-z0-9][a-z0-9._-]*@\d+(?:\.\d+)?$/;
    return legacyRegex.test(val) || namespacedRegex.test(val);
}, {
    message: 'Tool name must be either legacy format (alphanumeric) or namespaced format (<namespace>/<name>@<version>)'
})
    .describe('Tool name - legacy or namespaced format');
// Tool schema with networks, namespace, and versioning
export const ToolSchema = z.object({
    name: ToolNameSchema, // Now supports namespace/name@version format
    title: z.string().min(1).max(128).optional(), // Human-readable title
    description: z.string().optional(),
    version: z
        .string()
        .regex(/^\d+\.\d+\.\d+$/)
        .optional(), // Semantic version
    tags: z.array(z.string()).optional(), // Routing hints like ['cpu-heavy', 'batch']
    inputSchema: z.record(z.string(), z.unknown()).optional(),
    networks: z.array(NetworkIdSchema).optional()
});
// Mailbox mode validation
export const MailboxModeSchema = z.enum(['volatile', 'persistent']);
// Agent ID validation
export const AgentIdSchema = z
    .string()
    .min(1)
    .max(64)
    .regex(/^[a-z0-9]+$/i)
    .describe('Agent identifier');
// ============================================================================
// KADI PROTOCOL MESSAGE SCHEMAS
// ============================================================================
// Registration Schema - Updated to use 'networks' instead of 'scopes'
export const KadiRegisterParamsSchema = z
    .object({
    tools: z.array(ToolSchema).optional().default([]),
    displayName: z.string().min(1).max(64).optional(),
    mailboxMode: MailboxModeSchema.optional().default('volatile'),
    networks: z
        .union([
        // Changed from 'scopes'
        NetworkIdSchema,
        z.array(NetworkIdSchema)
    ])
        .transform((val) => (Array.isArray(val) ? val : [val])),
    parentAgentId: AgentIdSchema.optional()
})
    .refine((data) => data.networks.length > 0, {
    message: 'At least one network must be specified',
    path: ['networks']
});
// Registration Result
export const KadiRegisterResultSchema = z.object({
    agentId: z.string(),
    registered: z.number(),
    networks: z.array(NetworkIdSchema),
    mailbox: z.string(),
    mailboxMode: MailboxModeSchema
});
// Tool List params - Changed from 'scopes'
export const KadiToolListParamsSchema = z.object({
    networks: z.array(NetworkIdSchema).optional() // Filter by networks
});
// Tool invocation params
export const KadiToolInvokeParamsSchema = z.object({
    toolName: ToolNameSchema,
    toolInput: z.unknown().optional(),
    requestId: z.string().optional(),
    timeout: z.number().min(1000).max(300000).optional().default(30000),
    metadata: z.record(z.string(), z.unknown()).optional().default({})
});
// Tool result params
export const KadiToolResultParamsSchema = z.object({
    requestId: z.string(),
    result: z.unknown().optional(),
    error: z.unknown().optional(),
    metadata: z.record(z.string(), z.unknown()).optional().default({})
});
// ============================================================================
// VALIDATION MIDDLEWARE
// ============================================================================
export class ValidationMiddleware {
    static validateParams(method, params) {
        switch (method) {
            case 'kadi.agent.register':
                return KadiRegisterParamsSchema.parse(params);
            case 'kadi.ability.list':
                return KadiToolListParamsSchema.parse(params);
            case 'kadi.ability.invoke':
                return KadiToolInvokeParamsSchema.parse(params);
            case 'kadi.ability.result':
                return KadiToolResultParamsSchema.parse(params);
            default:
                return params;
        }
    }
}
//# sourceMappingURL=kadi.schemas.js.map