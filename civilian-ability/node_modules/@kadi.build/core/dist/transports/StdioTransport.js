/**
 * StdioTransport - Handles stdio communication for abilities
 *
 * This transport operates in two modes:
 *
 * CLIENT MODE: Spawns an ability as a child process and calls its methods
 * - Parent process sends JSON-RPC requests to child's stdin
 * - Child process sends JSON-RPC responses back via stdout
 *
 * SERVER MODE: Serves an ability's methods via stdio (when running as a child)
 * - Reads JSON-RPC requests from stdin
 * - Writes JSON-RPC responses to stdout
 *
 * Both modes use LSP-style message framing for reliable communication.
 * The transport handles all the complexity of:
 * - Process spawning and lifecycle management (client mode)
 * - Message framing and buffering
 * - Request/response correlation
 * - Timeout handling
 */
import { spawn } from 'node:child_process';
import path from 'node:path';
import fs from 'node:fs';
import { EventEmitter } from 'events';
import { createComponentLogger } from '../utils/logger.js';
// Constants for frame handling and timeouts
const DEFAULT_BUFFER_SIZE = 8 * 1024 * 1024; // 8MB max buffer size
const HEADER_SEARCH_WINDOW = 100; // bytes to keep when seeking headers
const PROCESS_START_DELAY_MS = 500; // delay after spawning process
/**
 * FrameReader - Reads LSP-style framed JSON messages from a stream
 *
 * This class solves the "message boundary" problem when reading from streams.
 * When you read from stdin/stdout, data arrives in chunks that don't align
 * with message boundaries. FrameReader ensures we extract complete messages.
 *
 * THE FRAMING PROTOCOL (LSP-style with KADI header):
 * Each message has this structure:
 * Kadi-Content-Length: 123\r\n\r\n{"jsonrpc":"2.0",...}
 */
class FrameReader {
    input;
    onMessage;
    buffer = Buffer.alloc(0); // Accumulates data chunks as they arrive
    maxBufferSize;
    logger;
    constructor(input, // The stream to read from (like process.stdout)
    onMessage, // Callback when complete message is parsed
    maxBufferSize = DEFAULT_BUFFER_SIZE, // 8MB limit to prevent memory exhaustion
    logger // Logger for reporting skipped bytes
    ) {
        this.input = input;
        this.onMessage = onMessage;
        this.maxBufferSize = maxBufferSize;
        this.logger = logger || createComponentLogger('FrameReader');
        // Listen for data chunks and process them as they arrive
        this.input.on('data', (chunk) => this.handleData(chunk));
    }
    /**
     * Process incoming data chunks and extract complete messages
     */
    handleData(chunk) {
        // Add new chunk to our accumulation buffer
        this.buffer = Buffer.concat([this.buffer, chunk]);
        // Safety check: prevent memory exhaustion from malformed streams
        if (this.buffer.length > this.maxBufferSize) {
            this.logger.error('handleData', `Buffer overflow: ${this.buffer.length} bytes`);
            this.buffer = Buffer.alloc(0);
            return;
        }
        // Process all complete messages in the buffer
        let processed = true;
        while (processed && this.buffer.length > 0) {
            processed = this.processFrame();
        }
    }
    /**
     * Process a single frame from the buffer
     */
    processFrame() {
        // Look for frame header
        const headerEnd = this.buffer.indexOf('\r\n\r\n');
        if (headerEnd === -1) {
            // No complete header yet, check if buffer is getting too large
            if (this.buffer.length > HEADER_SEARCH_WINDOW) {
                // Skip garbage bytes
                const skipped = this.buffer.length - HEADER_SEARCH_WINDOW;
                this.logger.debug('processFrame', `Skipping ${skipped} garbage bytes`);
                this.buffer = this.buffer.slice(skipped);
            }
            return false;
        }
        // Parse header
        const headerBytes = this.buffer.slice(0, headerEnd);
        const headerText = headerBytes.toString('utf8');
        // Extract content length
        const match = headerText.match(/Kadi-Content-Length:\s*(\d+)/i);
        if (!match) {
            // Invalid header, skip it
            this.buffer = this.buffer.slice(headerEnd + 4);
            return true;
        }
        const contentLength = parseInt(match[1], 10);
        const totalLength = headerEnd + 4 + contentLength;
        // Check if we have the complete message
        if (this.buffer.length < totalLength) {
            return false; // Wait for more data
        }
        // Extract message content
        const messageBytes = this.buffer.slice(headerEnd + 4, totalLength);
        const messageText = messageBytes.toString('utf8');
        // Parse JSON and emit
        try {
            const message = JSON.parse(messageText);
            this.onMessage(message);
        }
        catch (e) {
            this.logger.error('processFrame', `Failed to parse JSON: ${e}`);
        }
        // Remove processed message from buffer
        this.buffer = this.buffer.slice(totalLength);
        return true;
    }
}
/**
 * FrameWriter - Writes LSP-style framed JSON messages to a stream
 */
class FrameWriter {
    output;
    constructor(output) {
        this.output = output;
    }
    /**
     * Write a JSON message using LSP-style framing
     *
     * IMPORTANT: Content-Length is calculated in bytes, not characters.
     * This matters for UTF-8 strings where some characters use multiple bytes.
     */
    write(message) {
        // Convert message to JSON string
        const json = JSON.stringify(message);
        // Convert to UTF-8 bytes and measure actual byte length
        const jsonBuffer = Buffer.from(json, 'utf8');
        const contentLength = jsonBuffer.length;
        // Create the LSP-style header
        const header = `Kadi-Content-Length: ${contentLength}\r\n\r\n`;
        const headerBuffer = Buffer.from(header, 'utf8');
        // Write header + content as single atomic operation
        this.output.write(Buffer.concat([headerBuffer, jsonBuffer]));
    }
}
/**
 * StdioTransport - Manages child process abilities via stdio
 *
 * This transport provides process isolation and language independence.
 * The ability runs in a separate process and can be written in any
 * language that supports JSON-RPC over stdio.
 */
export class StdioTransport extends EventEmitter {
    options;
    logger;
    process;
    reader;
    writer;
    connected = false;
    pending = new Map();
    nextId = 1;
    constructor(options) {
        super();
        this.options = options;
        this.logger = createComponentLogger('StdioTransport');
        this.logger.lifecycle('constructor', `Creating stdio transport for ${options.abilityName}`);
    }
    /**
     * Connect by spawning the child process
     *
     * This method spawns the ability as a child process and sets up
     * the stdio communication channels.
     */
    async connect() {
        const { abilityName, abilityDir, startCmd } = this.options;
        this.logger.lifecycle('connect', `Loading ${abilityName} with stdio transport`);
        // Set KADI_PROTOCOL environment variable so the child knows how it's being run
        const env = { ...process.env, KADI_PROTOCOL: 'stdio' };
        const logFile = path.join(abilityDir, `${abilityName}.log`);
        this.logger.debug('connect', 'Spawning child process', {
            KADI_PROTOCOL: env.KADI_PROTOCOL,
            startCmd,
            cwd: abilityDir
        });
        // Spawn the child process that will run the ability
        // stdio: ['pipe', 'pipe', 'pipe'] creates pipes for stdin, stdout, stderr
        this.process = spawn(startCmd, {
            cwd: abilityDir,
            env,
            shell: true,
            stdio: ['pipe', 'pipe', 'pipe']
        });
        this.logger.info('connect', `Child process spawned with PID: ${this.process.pid}`);
        // Setup optional logging for stderr
        if (logFile) {
            try {
                fs.mkdirSync(path.dirname(logFile), { recursive: true });
                const logStream = fs.createWriteStream(logFile, { flags: 'a' });
                this.process.stderr?.pipe(logStream);
            }
            catch (e) {
                this.logger.warn('connect', `Unable to open log file: ${logFile}`, e);
            }
        }
        // Setup frame-based communication with the child process
        this.reader = new FrameReader(this.process.stdout, (msg) => this.handleMessage(msg), DEFAULT_BUFFER_SIZE, this.logger);
        this.writer = new FrameWriter(this.process.stdin);
        // Handle process events
        this.process.on('error', (error) => {
            this.logger.error('connect', 'Process error', error);
            this.cleanup();
            this.emit('error', error);
        });
        this.process.on('exit', (code, signal) => {
            this.logger.lifecycle('connect', `Process exited with code ${code}, signal ${signal}`);
            // Only cleanup if we haven't already
            if (this.connected) {
                this.cleanup();
                this.emit('disconnected');
            }
        });
        // Wait a moment for the process to start
        await new Promise((resolve) => setTimeout(resolve, PROCESS_START_DELAY_MS));
        this.connected = true;
        this.logger.lifecycle('connect', 'Stdio connection established');
        this.emit('connected');
    }
    /**
     * Handle incoming message from child process
     */
    handleMessage(msg) {
        const message = msg;
        // Check if it's a response to one of our requests
        if ('id' in message && message.id !== null && message.id !== undefined) {
            // Type guard to ensure we have a response with valid id
            const messageId = message.id;
            if (this.pending.has(messageId)) {
                const pending = this.pending.get(messageId);
                if (!pending)
                    return;
                if (pending.timer)
                    clearTimeout(pending.timer);
                this.pending.delete(messageId);
                // Type guard for response
                const response = message;
                if ('error' in response && response.error) {
                    pending.reject(new Error(response.error.message));
                }
                else {
                    pending.resolve(response.result);
                }
            }
        }
        // Handle notifications or events from the child
        if ('method' in message && !('id' in message)) {
            this.emit('notification', message);
            // Check for specific event types
            if (message.method === '__kadi_event') {
                const params = message.params;
                if (params && params.eventName) {
                    this.emit('event', { name: params.eventName, data: params.data });
                }
            }
        }
    }
    /**
     * Invoke a method on the child process ability
     *
     * Sends a JSON-RPC request to the child and waits for the response.
     */
    async invoke(method, params) {
        if (!this.connected || !this.writer) {
            throw new Error('Not connected to stdio process');
        }
        const id = this.nextId++;
        const request = {
            jsonrpc: '2.0',
            method,
            params,
            id
        };
        return new Promise((resolve, reject) => {
            // Store pending request (no default timeout)
            this.pending.set(id, { resolve, reject });
            // Send request to child
            try {
                this.writer.write(request);
                this.logger.trace('invoke', `Sent request ${id}: ${method}`);
            }
            catch (error) {
                this.pending.delete(id);
                reject(error);
            }
        });
    }
    /**
     * Get list of available methods
     */
    getMethods() {
        return [];
    }
    /**
     * Disconnect and cleanup
     *
     * Terminates the child process and cleans up resources.
     */
    async disconnect() {
        this.logger.lifecycle('disconnect', 'Disconnecting stdio transport');
        if (this.process && !this.process.killed) {
            // Try graceful shutdown first
            this.process.kill('SIGTERM');
            await new Promise((resolve) => setTimeout(resolve, 1000));
            // Force kill if still running
            // Check this.process again as it might be cleared by exit handler
            if (this.process && !this.process.killed) {
                this.process.kill('SIGKILL');
            }
        }
        this.cleanup();
        this.emit('disconnected');
    }
    /**
     * Cleanup resources
     */
    cleanup() {
        // Clear pending requests
        for (const [, pending] of this.pending) {
            if (pending.timer)
                clearTimeout(pending.timer);
            pending.reject(new Error('Connection closed'));
        }
        this.pending.clear();
        this.process = undefined;
        this.reader = undefined;
        this.writer = undefined;
        this.connected = false;
    }
    /**
     * Check if transport is connected
     */
    isConnected() {
        return this.connected;
    }
    /**
     * Publish an event to the parent process (when serving as child)
     */
    publishEvent(eventName, data) {
        this.logger.debug('publishEvent', `Publishing event via stdio: ${eventName}`);
        if (!this.writer) {
            this.logger.warn('publishEvent', 'No writer available for event publishing');
            return;
        }
        const notification = {
            jsonrpc: '2.0',
            method: '__kadi_event',
            params: {
                eventName,
                data,
                timestamp: Date.now()
            }
        };
        this.logger.trace('publishEvent', `Writing stdio event notification: ${JSON.stringify(notification)}`);
        this.writer.write(notification);
    }
    /**
     * Serve an ability via stdio (server mode)
     *
     * This method is used when the transport needs to serve an ability's methods
     * via stdio (when running as a child process). It reads JSON-RPC requests
     * from stdin and writes responses to stdout.
     *
     * @param ability - The ability (KadiClient) to serve
     */
    async serve(ability) {
        this.logger.lifecycle('serve', `Serving ${ability.name} via stdio`);
        // In server mode, we read from stdin and write to stdout
        // Keep both a local 'writer' and 'this.writer': local avoids non-null
        // assertions inside closures; instance lets publishEvent() use it elsewhere.
        const writer = new FrameWriter(process.stdout);
        this.writer = writer;
        const reader = new FrameReader(process.stdin, (msg) => {
            const request = msg;
            const { id, method, params } = request;
            void (async () => {
                try {
                    // Handle discovery request (use __kadi_list to match old handler)
                    if (method === '__kadi_list') {
                        const response = {
                            jsonrpc: '2.0',
                            result: {
                                methods: ability.getToolNames()
                            },
                            id
                        };
                        writer.write(response);
                        return;
                    }
                    // Handle method invocation
                    const handler = ability.getToolHandler(method);
                    if (!handler) {
                        const response = {
                            jsonrpc: '2.0',
                            error: {
                                code: -32601,
                                message: `Method '${method}' not found`
                            },
                            id
                        };
                        writer.write(response);
                        return;
                    }
                    // Execute the method
                    const result = await handler(params);
                    const response = {
                        jsonrpc: '2.0',
                        result,
                        id
                    };
                    writer.write(response);
                }
                catch (error) {
                    const response = {
                        jsonrpc: '2.0',
                        error: {
                            code: -32603,
                            message: error instanceof Error ? error.message : 'Internal error',
                            data: error instanceof Error ? error.stack : undefined
                        },
                        id
                    };
                    writer.write(response);
                }
            })();
        }, DEFAULT_BUFFER_SIZE, this.logger);
        this.reader = reader;
        // Emit that we're ready to serve
        this.emit('serving');
        // Keep the process alive
        return new Promise(() => {
            // This promise never resolves, keeping the server running
        });
    }
}
//# sourceMappingURL=StdioTransport.js.map