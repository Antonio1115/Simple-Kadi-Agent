/**
 * NativeTransport - Handles direct in-process ability loading
 *
 * This transport loads abilities directly into the same process,
 * allowing for zero-overhead method invocation. It's used when
 * you want to load local JavaScript/TypeScript modules as abilities.
 *
 * The native protocol is the fastest but requires the ability code
 * to be trusted since it runs in the same process.
 */
import path from 'node:path';
import { EventEmitter } from 'events';
import { createComponentLogger } from '../utils/logger.js';
/**
 * NativeTransport - Loads and executes abilities in the same process
 *
 * This transport provides the fastest execution since there's no
 * serialization or IPC overhead. The ability code runs directly
 * in the Node.js process.
 */
export class NativeTransport extends EventEmitter {
    options;
    logger;
    ability;
    methodHandlers = new Map();
    connected = false;
    constructor(options) {
        super();
        this.options = options;
        this.logger = createComponentLogger('NativeTransport');
        this.logger.lifecycle('constructor', `Creating native transport for ${options.abilityName}`);
    }
    /**
     * Connect by loading the ability module into memory
     *
     * This method uses JavaScript's native import to load the ability,
     * delegating all module resolution complexity to Node.js itself.
     */
    async connect() {
        const { abilityName, abilityDir } = this.options;
        this.logger.lifecycle('connect', `Loading ${abilityName} as native module`);
        this.logger.debug('connect', `abilityDir received: ${abilityDir}`);
        this.logger.debug('connect', `process.cwd(): ${process.cwd()}`);
        // Set environment variable so the module knows it's being loaded via native protocol
        const originalProtocol = process.env.KADI_PROTOCOL;
        process.env.KADI_PROTOCOL = 'native';
        let rawModule;
        try {
            // Convert to absolute path if needed
            const baseDir = path.isAbsolute(abilityDir)
                ? abilityDir
                : path.resolve(process.cwd(), abilityDir);
            // Resolve the actual entry file
            // ES modules require importing a file, not a directory
            let entryFile;
            // Check for package.json main field
            const packageJsonPath = path.join(baseDir, 'package.json');
            try {
                const fs = await import('node:fs');
                const packageJson = JSON.parse(fs.default.readFileSync(packageJsonPath, 'utf-8'));
                if (packageJson.main) {
                    entryFile = path.join(baseDir, packageJson.main);
                    this.logger.debug('connect', `Using package.json main: ${packageJson.main}`);
                }
                else {
                    throw new Error('No main field in package.json');
                }
            }
            catch (error) {
                // Fallback to common entry points
                const fs = await import('node:fs');
                const commonEntries = ['service.js', 'index.js', 'index.mjs'];
                entryFile = '';
                for (const entry of commonEntries) {
                    const testPath = path.join(baseDir, entry);
                    if (fs.default.existsSync(testPath)) {
                        entryFile = testPath;
                        this.logger.debug('connect', `Using fallback entry: ${entry}`);
                        break;
                    }
                }
                if (!entryFile) {
                    throw new Error(`No entry point found in ${baseDir}`);
                }
            }
            this.logger.debug('connect', `Importing from: ${entryFile}`);
            // Import the actual file
            const mod = await import(entryFile);
            rawModule = mod.default || mod;
            this.logger.debug('connect', `Successfully imported module`);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.logger.error('connect', `Failed to import ability: ${errorMessage}`);
            // Provide helpful error message
            throw new Error(`Cannot load ability '${abilityName}' from ${abilityDir}. ` +
                `Make sure the ability has either:\n` +
                `  1. A package.json with a "main" field pointing to the entry file\n` +
                `  2. An index.js file in the root directory\n` +
                `Original error: ${errorMessage}`);
        }
        finally {
            // Restore original environment
            if (originalProtocol !== undefined) {
                process.env.KADI_PROTOCOL = originalProtocol;
            }
            else {
                delete process.env.KADI_PROTOCOL;
            }
        }
        // Extract methods from the imported module
        await this.extractMethods(rawModule, abilityName);
        this.connected = true;
        this.logger.lifecycle('connect', 'Native ability loaded successfully');
        this.emit('connected');
    }
    /**
     * Extract methods from the loaded module
     *
     * Handles different export formats:
     * - KadiClient/KadiAbility instances
     * - Plain objects with function properties
     * - Class constructors
     */
    async extractMethods(rawModule, abilityName) {
        if (typeof rawModule === 'object' && rawModule !== null) {
            // Check if this is a KadiClient or KadiAbility instance
            if (rawModule.constructor?.name === 'KadiClient' ||
                rawModule.constructor?.name === 'KadiAbility' ||
                typeof rawModule.getToolNames === 'function') {
                this.logger.debug('extractMethods', 'Detected KadiClient/KadiAbility instance');
                // Extract methods from KadiClient/KadiAbility
                const methodNames = rawModule.getToolNames();
                for (const methodName of methodNames) {
                    const handler = rawModule.getToolHandler(methodName);
                    if (handler) {
                        this.methodHandlers.set(methodName, handler);
                    }
                }
                this.ability = rawModule;
                // Forward events if the ability supports them
                if (typeof rawModule.on === 'function') {
                    /**
                     * Listen for the internal transport event from the loaded ability.
                     * KadiClient instances emit __KADI_INTERNAL_ABILITY_EVENT_TRANSPORT__ when
                     * they publish events in native mode. We catch these and forward them
                     * to the AbilityProxy as regular 'event' emissions.
                     */
                    const ABILITY_EVENT_TRANSPORT = '__KADI_INTERNAL_ABILITY_EVENT_TRANSPORT__';
                    this.logger.trace('extractMethods', `Setting up ${ABILITY_EVENT_TRANSPORT} listener on rawModule`);
                    rawModule.on(ABILITY_EVENT_TRANSPORT, (eventData) => {
                        this.logger.trace('extractMethods', `Received ${ABILITY_EVENT_TRANSPORT} from rawModule: ${JSON.stringify(eventData)}`);
                        this.logger.debug('extractMethods', 'Emitting event on transport');
                        this.emit('event', eventData);
                    });
                }
                else {
                    this.logger.debug('extractMethods', 'rawModule does not support .on() method');
                }
            }
            else {
                // Plain object with methods as properties
                this.logger.debug('extractMethods', 'Processing plain object with methods');
                for (const [key, value] of Object.entries(rawModule)) {
                    if (typeof value === 'function' && !key.startsWith('_')) {
                        this.methodHandlers.set(key, value);
                    }
                }
                this.ability = rawModule;
            }
        }
        else if (typeof rawModule === 'function') {
            // Class constructor - instantiate and extract methods
            this.logger.debug('extractMethods', 'Processing class constructor');
            const instance = new rawModule();
            const prototype = Object.getPrototypeOf(instance);
            const methodNames = Object.getOwnPropertyNames(prototype).filter((name) => name !== 'constructor' &&
                !name.startsWith('_') &&
                typeof prototype[name] === 'function');
            for (const name of methodNames) {
                const method = instance[name];
                if (typeof method === 'function') {
                    this.methodHandlers.set(name, method.bind(instance));
                }
            }
            this.ability = instance;
        }
        else {
            throw new Error(`Unsupported module export type for ability '${abilityName}'`);
        }
        this.logger.info('extractMethods', `Extracted ${this.methodHandlers.size} methods from ${abilityName}`);
    }
    /**
     * Invoke a method on the loaded ability
     *
     * Since this is native, we just call the function directly
     * with no serialization overhead.
     */
    async invoke(method, params) {
        if (!this.connected) {
            throw new Error('Native ability not loaded');
        }
        this.logger.trace('invoke', `Invoking method: ${method}`);
        const handler = this.methodHandlers.get(method);
        if (!handler) {
            throw new Error(`Method '${method}' not found in native ability`);
        }
        try {
            // Direct function call - no serialization needed
            const result = await handler(params);
            this.logger.trace('invoke', `Method ${method} completed successfully`);
            return result;
        }
        catch (error) {
            this.logger.error('invoke', `Method ${method} failed: ${error}`);
            throw error;
        }
    }
    /**
     * Get list of available methods
     */
    getMethods() {
        return Array.from(this.methodHandlers.keys());
    }
    /**
     * Get schema for a specific method (if available)
     */
    getMethodSchema(method) {
        // If the ability is a KadiClient/KadiAbility, it might have schema info
        if (this.ability && typeof this.ability.getMethodSchema === 'function') {
            return this.ability.getMethodSchema(method);
        }
        return undefined;
    }
    /**
     * Disconnect and cleanup
     *
     * Releases references to the loaded module to allow garbage collection
     */
    async disconnect() {
        this.logger.lifecycle('disconnect', 'Disconnecting native transport');
        // Call the ability's disconnect method if it exists
        // This is crucial for native abilities to clean up properly.
        // When an ability is loaded natively, it may have called serve()
        // which creates a promise keeping the process alive. Calling
        // disconnect() on the ability resolves that promise.
        if (this.ability && typeof this.ability.disconnect === 'function') {
            this.logger.debug('disconnect', 'Calling ability disconnect method');
            await this.ability.disconnect();
        }
        this.ability = undefined;
        this.methodHandlers.clear();
        this.connected = false;
        this.emit('disconnected');
    }
    /**
     * Check if transport is connected
     */
    isConnected() {
        return this.connected;
    }
}
//# sourceMappingURL=NativeTransport.js.map