/**
 * BrokerTransport - Handles communication with remote abilities via broker
 *
 * This transport connects to a broker (WebSocket server) to invoke methods
 * on remote agents/abilities. Unlike Native and Stdio transports which load
 * local code, BrokerTransport is purely a client that calls remote services.
 *
 * The broker acts as a message router, allowing agents to discover and
 * invoke each other's methods across network boundaries.
 *
 * Communication Flow:
 * 1. Connect to broker via WebSocket
 * 2. Authenticate and join networks
 * 3. Discover available methods from target agent
 * 4. Send method invocations through broker
 * 5. Receive results back through broker
 */
import { EventEmitter } from 'events';
import { createComponentLogger } from '../utils/logger.js';
/**
 * BrokerTransport - Client for invoking methods on remote agents
 *
 * This transport is a thin wrapper around KadiClient's broker functionality.
 * It creates an ephemeral KadiClient instance that connects to the broker
 * solely for the purpose of calling methods on a remote agent.
 *
 * Unlike serving mode (where an agent registers its own methods),
 * this transport is purely a consumer of remote methods.
 */
export class BrokerTransport extends EventEmitter {
    options;
    logger;
    client;
    targetAgent;
    connected = false;
    constructor(options) {
        super();
        this.options = options;
        this.targetAgent = options.targetAgent || options.abilityName;
        this.logger = createComponentLogger('BrokerTransport');
        if (!options.existingClient) {
            throw new Error('BrokerTransport requires an existing KadiClient');
        }
        this.client = options.existingClient;
        this.logger.lifecycle('constructor', `Creating broker transport for target: ${this.targetAgent} using existing client`);
    }
    /**
     * Connect to the broker and discover target agent's methods
     *
     * This creates an ephemeral KadiClient that connects to the broker
     * as a client (not serving any methods of its own).
     */
    async connect() {
        this.logger.lifecycle('connect', `Connecting to broker for target agent: ${this.targetAgent}`);
        try {
            // Connect to specific broker if not already connected
            const brokerUrl = this.options.brokerUrl;
            if (!brokerUrl) {
                throw new Error('Broker URL is required for BrokerTransport');
            }
            // Check if we're already connected to this specific broker
            const isConnectedToRightBroker = this.client.isConnectedToBroker(brokerUrl);
            if (!isConnectedToRightBroker) {
                // Need to connect to the specific broker
                this.logger.info('connect', `Connecting to specific broker: ${brokerUrl}`);
                // Connect only to the specific broker requested
                await this.client.connectToBroker(brokerUrl, this.options.brokerName);
            }
            else {
                this.logger.info('connect', `Already connected to broker: ${brokerUrl}`);
            }
            // OLD CODE - Connect to all brokers
            // await this.client.connectToBrokers();
            this.logger.info('connect', `Connected to broker at ${this.options.brokerUrl}`);
            // Discover available tools in the network to verify target exists
            this.logger.debug('connect', `Discovering tools in network to verify ${this.targetAgent} exists`);
            const toolsResponse = await this.client.sendBrokerRequest('kadi.ability.list', {
                networks: this.client.networks || ['global'],
                includeProviders: true
            });
            // Check if any tools are provided by an agent matching our target name
            const tools = toolsResponse.tools || [];
            const targetProviders = new Set();
            const availableAgents = new Set();
            for (const tool of tools) {
                if (tool.providers) {
                    for (const provider of tool.providers) {
                        // Track all available agents for error message (prefer displayName)
                        const agentName = provider.displayName || provider.agentId;
                        availableAgents.add(agentName);
                        // Check if this provider matches our target
                        // Match by displayName or if the targetAgent appears to be an agentId
                        if (provider.displayName === this.targetAgent ||
                            provider.agentId === this.targetAgent) {
                            targetProviders.add(provider.agentId);
                        }
                    }
                }
            }
            if (targetProviders.size === 0) {
                const networks = this.client.networks || ['global'];
                const availableList = Array.from(availableAgents).sort();
                throw new Error(`Ability '${this.targetAgent}' not found in networks [${networks.join(', ')}].\n` +
                    `Available abilities in these networks:\n${availableList.map((a) => `  - ${a}`).join('\n')}\n\n` +
                    `Make sure the ability is running and connected to the broker.`);
            }
            this.logger.info('connect', `Found ${this.targetAgent} in network with ${targetProviders.size} provider(s)`);
            this.connected = true;
            this.logger.lifecycle('connect', `Broker transport connected to ${this.targetAgent}`);
            this.emit('connected');
        }
        catch (error) {
            this.logger.error('connect', `Failed to connect to broker: ${error}`);
            throw error;
        }
    }
    /**
     * Invoke a method on the remote agent
     *
     * Sends the method invocation through the broker to the target agent.
     */
    async invoke(method, params) {
        if (!this.connected || !this.client) {
            throw new Error('Not connected to broker');
        }
        this.logger.trace('invoke', `Invoking ${this.targetAgent}.${method}`);
        try {
            // Use KadiClient's remote tool invocation
            const result = await this.client.callTool(this.targetAgent, method, params);
            this.logger.trace('invoke', `Method ${method} completed successfully`);
            return result;
        }
        catch (error) {
            this.logger.error('invoke', `Failed to invoke ${this.targetAgent}.${method}: ${error}`);
            throw error;
        }
    }
    /**
     * Get list of discovered methods
     *
     * Returns empty array as broker transport doesn't do method discovery.
     */
    getMethods() {
        return [];
    }
    /**
     * Disconnect from the broker
     *
     * Since we're reusing an existing client, we don't actually disconnect it
     * (other parts of the app might still be using it)
     */
    async disconnect() {
        this.logger.lifecycle('disconnect', 'Disconnecting broker transport');
        // Don't disconnect the shared client - just mark ourselves as disconnected
        // The client is managed by the main application
        this.connected = false;
        if (this.client) {
            await this.client.disconnect();
        }
        this.emit('disconnected');
    }
    /**
     * Check if transport is connected
     */
    isConnected() {
        return this.connected;
    }
    /**
     * Get the target agent name
     *
     * Useful for debugging and logging
     */
    getTargetAgent() {
        return this.targetAgent;
    }
}
//# sourceMappingURL=BrokerTransport.js.map