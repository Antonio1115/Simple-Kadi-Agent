/**
 * BrokerTransport - Handles communication with remote abilities via broker
 *
 * This transport connects to a broker (WebSocket server) to invoke methods
 * on remote agents/abilities. Unlike Native and Stdio transports which load
 * local code, BrokerTransport is purely a client that calls remote services.
 *
 * The broker acts as a message router, allowing agents to discover and
 * invoke each other's methods across network boundaries.
 *
 * Communication Flow:
 * 1. Connect to broker via WebSocket
 * 2. Authenticate and join networks
 * 3. Discover available methods from target agent
 * 4. Send method invocations through broker
 * 5. Receive results back through broker
 */
import { EventEmitter } from 'events';
import { Transport, TransportOptions } from './Transport.js';
import { KadiClient } from '../KadiClient.js';
/**
 * Options specific to BrokerTransport
 */
interface BrokerTransportOptions extends TransportOptions {
    /**
     * The target agent name we want to call methods on
     * This is the remote agent that has the methods we want to invoke
     */
    targetAgent: string;
    /**
     * Existing KadiClient to reuse (if already connected to broker)
     */
    existingClient?: KadiClient;
    /**
     * WebSocket URL of the broker (required if no existing client)
     */
    brokerUrl?: string;
    /**
     * Name of the broker (for logging/identification)
     */
    brokerName?: string;
    /**
     * Networks to join for discovering agents
     */
    networks?: string[];
}
/**
 * BrokerTransport - Client for invoking methods on remote agents
 *
 * This transport is a thin wrapper around KadiClient's broker functionality.
 * It creates an ephemeral KadiClient instance that connects to the broker
 * solely for the purpose of calling methods on a remote agent.
 *
 * Unlike serving mode (where an agent registers its own methods),
 * this transport is purely a consumer of remote methods.
 */
export declare class BrokerTransport extends EventEmitter implements Transport {
    private options;
    private logger;
    private client;
    private targetAgent;
    private connected;
    constructor(options: BrokerTransportOptions);
    /**
     * Connect to the broker and discover target agent's methods
     *
     * This creates an ephemeral KadiClient that connects to the broker
     * as a client (not serving any methods of its own).
     */
    connect(): Promise<void>;
    /**
     * Invoke a method on the remote agent
     *
     * Sends the method invocation through the broker to the target agent.
     */
    invoke(method: string, params: unknown): Promise<unknown>;
    /**
     * Get list of discovered methods
     *
     * Returns empty array as broker transport doesn't do method discovery.
     */
    getMethods(): string[];
    /**
     * Disconnect from the broker
     *
     * Since we're reusing an existing client, we don't actually disconnect it
     * (other parts of the app might still be using it)
     */
    disconnect(): Promise<void>;
    /**
     * Check if transport is connected
     */
    isConnected(): boolean;
    /**
     * Get the target agent name
     *
     * Useful for debugging and logging
     */
    getTargetAgent(): string;
}
export {};
//# sourceMappingURL=BrokerTransport.d.ts.map